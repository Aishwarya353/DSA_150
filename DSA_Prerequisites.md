# Prerequisites & Foundations for DSA

### 1. **Asymptotic Notations (Big O, Big Ω, Big Θ)**

* **Big O (O)**: Upper bound (worst-case time complexity)
* **Big Omega (Ω)**: Lower bound (best-case time complexity)
* **Big Theta (Θ)**: Tight bound (both upper & lower)
* Why it matters: Understand how algorithms scale with input size.

### 2. **Time Complexity (TC)**

* Measure of the number of operations an algorithm takes relative to input size (n).
* Examples: O(1), O(log n), O(n), O(n log n), O(n²), etc.

### 3. **Space Complexity (SC)**

* Amount of extra memory an algorithm uses relative to input size.
* Important for understanding memory usage.

### 4. **Basic Math & Logarithms**

* Logarithmic functions (log base 2, natural log)
* Understanding how binary search runs in O(log n) time.

### 5. **Data Types & Variables**

* Primitive data types (int, float, boolean, etc.)
* Arrays, lists, and how indexing works.

### 6. **Pointers & References (especially for languages like C, C++)**

* Understand how memory referencing works (less critical for Python but helpful conceptually).

### 7. **Recursion**

* Function calling itself with a smaller input
* How to trace recursive calls
* Base case and recursive case
* Relation to stack space usage.

### 8. **Iteration & Loops**

* For, while loops and how they contribute to time complexity.

### 9. **Algorithm Paradigms**

* Brute force
* Divide and conquer
* Greedy algorithms (basic understanding)
* Dynamic programming (overview)

### 10. **Basic Data Structures**

* Arrays & Lists
* Stacks & Queues
* Linked Lists (singly and doubly)
* Trees (binary trees, binary search trees)
* Hash tables / Hash maps
* Graphs (basics)
